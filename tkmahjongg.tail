########################################################################
## tkmahjongg.tail

# revvid lut
foreach tile $tiles_normal {
    set revvid($tile) $tile-inv
    set revvid($tile-inv) $tile
}

# default layout
set tileDesc { }

proc set_board name {
    global board_data tileDesc
    set tileDesc [split [string trim $board_data($name)] "\n"]
}

# tile info
# format: tile_class num_to_create list_of_tiles_it_matches
set tile_info(bamboo1) {0 4 {bamboo1}}
set tile_info(bamboo2) {0 4 {bamboo2}}
set tile_info(bamboo3) {0 4 {bamboo3}}
set tile_info(bamboo4) {0 4 {bamboo4}}
set tile_info(bamboo5) {0 4 {bamboo5}}
set tile_info(bamboo6) {0 4 {bamboo6}}
set tile_info(bamboo7) {0 4 {bamboo7}}
set tile_info(bamboo8) {0 4 {bamboo8}}
set tile_info(bamboo9) {0 4 {bamboo9}}
set tile_info(pin1) {1 4 {pin1}}
set tile_info(pin2) {1 4 {pin2}}
set tile_info(pin3) {1 4 {pin3}}
set tile_info(pin4) {1 4 {pin4}}
set tile_info(pin5) {1 4 {pin5}}
set tile_info(pin6) {1 4 {pin6}}
set tile_info(pin7) {1 4 {pin7}}
set tile_info(pin8) {1 4 {pin8}}
set tile_info(pin9) {1 4 {pin9}}
set tile_info(man1) {2 4 {man1}}
set tile_info(man2) {2 4 {man2}}
set tile_info(man3) {2 4 {man3}}
set tile_info(man4) {2 4 {man4}}
set tile_info(man5) {2 4 {man5}}
set tile_info(man6) {2 4 {man6}}
set tile_info(man7) {2 4 {man7}}
set tile_info(man8) {2 4 {man8}}
set tile_info(man9) {2 4 {man9}}
set tile_info(wind-north) {3 4 {wind-north}}
set tile_info(wind-south) {3 4 {wind-south}}
set tile_info(wind-east) {3 4 {wind-east}}
set tile_info(wind-west) {3 4 {wind-west}}
set tile_info(flower-bamboo) {4 1 {flower-bamboo flower-orchid flower-plum flower-chrysanthemum}}
set tile_info(flower-orchid) {4 1 {flower-bamboo flower-orchid flower-plum flower-chrysanthemum}}
set tile_info(flower-plum) {4 1 {flower-bamboo flower-orchid flower-plum flower-chrysanthemum}}
set tile_info(flower-chrysanthemum) {4 1 {flower-bamboo flower-orchid flower-plum flower-chrysanthemum}}
set tile_info(season-spring) {5 1 {season-spring season-summer season-autumn season-winter}}
set tile_info(season-summer) {5 1 {season-spring season-summer season-autumn season-winter}}
set tile_info(season-autumn) {5 1 {season-spring season-summer season-autumn season-winter}}
set tile_info(season-winter) {5 1 {season-spring season-summer season-autumn season-winter}}
set tile_info(dragon-green) {6 4 {dragon-green}}
set tile_info(dragon-chun) {6 4 {dragon-chun}}
set tile_info(dragon-haku) {6 4 {dragon-haku}}

########################################################################

# process args
catch {rename send {}}
if ![catch {set geometry}] {
    catch {wm geometry . $geometry}
}
while {[llength $argv]} {
    if {[lindex $argv 0]=="-vb"} {
        set vbell 1
    } elseif {[lindex $argv 0]=="-l"} {
        set startupLayout [lindex $argv 1]
        set argv [lreplace $argv 0 0]
    } elseif {[lindex $argv 0]=="-b"} {
        set rSeed [expr int([lindex $argv 1]) % 1000000000]
        set argv [lreplace $argv 0 0]
    } else {
        puts stderr "unknown option: [lindex $argv 0]"
        exit 1
    }
    set argv [lreplace $argv 0 0]
}

# create main UI
. configure -background $wbg
# compute grid size if in text mode
set wtile 128
set htile 128

set halfw [expr 0.5*$wtile]
set halfh [expr 0.5*$htile]
set xsp [expr $wtile+4]
set ysp [expr $htile+4]
set xhalfw [expr 0.5*$xsp]
set xhalfh [expr 0.5*$ysp]
canvas .c -width [expr $xsp*15+12] -height [expr $ysp*8+12] \
        -bd 0 -highlightthickness 0 -background $wbg
pack .c -side bottom -padx 2 -pady 2
.c configure -cursor watch

button .about -text $blbl(about) -fg $wfg -bg $wbg \
        -font $blfont -command {
    .c delete all
    .c configure -cursor crosshair
    about
    update
    bind .c <1> {
        .c configure -cursor {}
        bind .c <1> {}
        draw
    }
}

button .new -fg $wfg -bg $wbg -text $blbl(new) \
        -font $blfont -command {
    if [query] newGame
}

button .replay -fg $wfg -bg $wbg -text $blbl(replay) \
        -font $blfont -command {
    if [query] replay
}

#button .load -fg $wfg -bg $wbg -text $blbl(load) \
#        -font $blfont -command {
#    if [query] {
#        set f [tk_getOpenFile -parent .c -title {Load Board}]
#        if {$f!={}} { newGame $f }
#    }
#}

button .undo -fg $wfg -bg $wbg -state disabled -font $blfont \
        -text $blbl(undo) \
-command {
    set cmd [lindex $undoInfo end]
    if [catch {set undoInfo [lreplace $undoInfo end end]}] { set undoInfo {} }
    if ![llength $undoInfo] {
        .undo configure -state disabled
    }
    eval $cmd
}

button .quit -fg $wfg -bg $wbg -text Quit -font $blfont \
        -command { if [query] exit }

button .help -fg $wfg -bg $wbg -text Help -font $blfont \
        -command {wm deiconify .xhelp; raise .xhelp}

# labels on right
label .lg -text $blbl(game) -fg $wfg -bg $wbg \
        -font $blfont

label .lgame -textvariable gSeed -width 10 -anchor e -fg $wfg -bg $wbg \
        -font $blfont

# shim
label .ld -width 2 -fg $wfg -bg $wbg

label .lr -text $blbl(rem) -fg $wfg -bg $wbg \
        -font $blfont

label .rem -textvariable nTiles -width 3 -fg $wfg -bg $wbg \
        -font $blfont

foreach b {.about .new .replay .quit .help} {
    $b configure -state disabled
}
pack .about .new .replay .undo .quit .help -side left
pack .rem .lr .ld .lgame .lg -side right

proc about {} {
    global afont xhalfh xhalfw wfg

    .c create text [expr $xhalfw*15] [expr $xhalfh*1.0] -text "TkMahjongg" \
        -font $afont -fill $wfg
    .c create text [expr $xhalfw*15] [expr $xhalfh*2.6] \
        -text "by Mark Hays  <fin13782654@gmail.com>" \
        -font $afont -fill $wfg
    .c create text [expr $xhalfw*15] [expr $xhalfh*4.5] \
        -font $afont -fill $wfg \
        -anchor center -justify center \
        -text \
{Copyright (c) 1997-2019 by Mark Hays. All Rights Reserved.}

    .c create text [expr $xhalfw*15] [expr $xhalfh*7] \
        -font $afont -fill $wfg \
        -anchor n -justify center \
        -text \
{Board layouts were pilfered from XMahjongg

XMahjongg Layouts are Copyright (c) 1990 by
Jeff Young  <jsy@cray.com>

Graphical Tiles are Copyright by
Martin Persson  <contact@martinpersson.org>
http://www.martinpersson.org
}
}

about
wm resizable . 0 0
wm title . TkMahjongg
update

# if a game is in progress, confirm a destructive operation
proc query {} {
    if {[.undo cget -state]!={disabled}} {
        return [tk_dialog .qdlg Abort? {Abort Current Game?} {} 0 No Yes]
    }
    return 1
}

# help display
toplevel .xhelp
wm withdraw .xhelp
wm resizable .xhelp 0 0
wm title .xhelp {TkMahjongg Help}
wm protocol .xhelp WM_DELETE_WINDOW {wm withdraw .xhelp}
scrollbar .xhelp.s -orient vertical -command {.xhelp.t yview}
text .xhelp.t -yscrollcommand {.xhelp.s set} -font $hfont -width 66
button .xhelp.b -text Close -command {wm withdraw .xhelp}
pack .xhelp.b -side bottom -fill x
pack .xhelp.s -side right -fill y
pack .xhelp.t -fill both
.xhelp.t insert end $tkmahjongg_help
.xhelp.t configure -state disabled

# create images
set iList {}
foreach name [array names tile_info] {
    foreach {cls n match} $tile_info($name) {
        for {set i 0} {$i<$n} {incr i} {
            set in ${name}_$i
            set image_to_name($in) $name
            set reversed($in) 0
            image create photo $in -data $image_data($name) -format PNG
            lappend iList $in
        }
    }
}

# this determines if a tile is free
proc isFree tile {
    global tab

    set tl [.c gettags $tile]
    set xy [split [lindex $tl [lsearch -glob $tl *:*:*]] {:}]
    set x  [lindex $xy 0]
    set y  [lindex $xy 1]
    set l  [lindex $xy 2]
    set no 0
    # check LR
    incr x -2
    if {[array names tab $x:$y:$l]!={}} { incr no } else {
        if {[array names tab $x:[expr $y-1]:$l]!={}} { incr no } else {
            if {[array names tab $x:[expr $y+1]:$l]!={}} { incr no }
        }

    }
    incr x 4
    if {[array names tab $x:$y:$l]!={}} { incr no } else {
        if {[array names tab $x:[expr $y-1]:$l]!={}} { incr no } else {
            if {[array names tab $x:[expr $y+1]:$l]!={}} { incr no }
        }
    }
    incr x -2
    # check above
    incr l
    foreach {dx dy} {-1 -1   0 -1   1 -1
                     -1  0   0  0   1  0
                     -1  1   0  1   1  1} {
        if {[array names tab [expr $x+$dx]:[expr $y+$dy]:$l]!={}} {
            incr no
        }
    }
    # done
    if {$no>1} { return 0 }
    return 1
}

# this gets called when something illegal happens
if !$vbell {
    proc deny {} bell
} else {
    proc deny {} {
        global wfg

        set ob [. cget -background]
        . configure -background $wfg
        update
        after 100
        . configure -background $ob
        update
    }
}

proc revVid tile {
    global image_data image_to_name reversed
    set name $image_to_name($tile)
    if {$reversed($tile) == 1} {
        $tile configure -data $image_data($name)
        set reversed($tile) 0
    } else {
        $tile configure -data $image_data($name-inv)
        set reversed($tile) 1
    }
}

# this proc performs a move
proc doMove {t1 t2} {
    global nTiles sel tab tile_info undoInfo

    # see if they're compatible
    set type1 [lindex [split $t1 {_}] 0]
    set type2 [lindex [split $t2 {_}] 0]
    if {[lsearch -exact [lindex $tile_info($type1) 2] $type2]==-1} {
        deny
        return
    }
    # success!
    # restore selected tile
    revVid $t1
    # delete them
    set u {}
    set tl [.c gettags $t1]
    set xyl [lindex $tl [lsearch -glob $tl *:*:*]]
    unset tab($xyl)
    append u [concat put [split $xyl {:}] $t1]
    .c delete $t1
    .c delete rect_$t1
    set tl [.c gettags $t2]
    set xyl [lindex $tl [lsearch -glob $tl *:*:*]]
    unset tab($xyl)
    append u [concat {;} put [split $xyl {:}] $t2 {;} draw {;} incr nTiles 2]
    .c delete $t2
    .c delete rect_$t2
    incr nTiles -2
    set sel {}
    lappend undoInfo $u
    .undo configure -state normal
}

# this processes mouse events
set sel {}

proc doSel v {
    global sel
    if ![isFree $v] { deny; return }
    if {$v==$sel} {
        # deselect it
        set sel {}
        revVid $v
        set sel {}
    } else {
        # do move
        if {$sel!=""} {
            doMove $sel $v
        } else {
            revVid $v
            set sel $v
        }
    }
}

########################################################################

# this does global game initialization
proc setup {} {
    global undoInfo
    set undoInfo {}
    .undo configure -state disabled
}

# this initializes the tile table
proc initTab {} {
    global tab
    catch {unset tab}
}

if {$rSeed<0} {
    set rSeed [expr [clock seconds] % 1000000000]
    expr srand($rSeed)
}

proc ranbyte {} {
    return [expr int(rand() * 256)]
}

proc pop {x} {
    set p 0
    while {$x > 0} {
        incr p [expr $x  & 1]
        set  x [expr $x >> 1]
    }
    return $p
}

proc cl2 {x} {
    if {$x < 1} { error {x must be positive} }
    set x [expr $x - 1]
    for {set i 0} {$i < 6} {incr i} {
        set x [expr $x | ($x >> (1 << $i))]
    }
    return [pop $x]
}

proc rng {n} {
    if {$n == 1} { return 0 }
    if {$n  < 2} { error {n must be positive} }
    set b [cl2 $n]
    set B [expr ($b + 7) >> 3]
    set N [expr 1 << ($B << 3)]
    set S [expr $N / $n]
    set d [expr $N % $n]
    set L [expr $N - $d]
    while {1} {
        set j 0
        for {set i 0} {$i < $B} {incr i} {
            set j [expr ($j << 8) | [ranbyte]]
        }
        if {$j < $L} { return [expr $j / $S] }
    }
}

proc shuffle {} {
    global deck iList gSeed rSeed
    set gSeed $rSeed
    set rSeed [expr int(rand() * 1000000000)]
    set deck $iList
    for {set i [expr [llength $deck] - 1]} {$i >= 1} {incr i -1} {
        set j [rng $i]
        set t [lindex $deck $i]
        set l [lreplace $deck $i $i [lindex $deck $j]]
        set deck [lreplace $l $j $j $t]
    }
}

# this places a tile into the tile table
proc put {x y l img} {
    global tab
    set tab($x:$y:$l) $img
}

# this reads a tile description file
proc loadFile {{filename {}}} {
    global tileDesc
    if {$filename=={}} return
    set tileDesc {}
    set nLines 0
    set file [open $filename r]
    while {[gets $file line]>=0} {
        set data [lindex [split $line {#}] 0]
        if [llength $data] {
            set y [lindex $data 0]
            set x [lindex $data 1]
            set l [lindex $data 2]
            lappend tileDesc [list $y $x $l]
            incr nLines
        }
    }
    close $file
    if {$nLines!=144} {
        puts stderr "deck description $filename bogus"
        exit 1
    }
}

# this deals the tiles
proc deal {{layout {}}} {
    global deck nTiles tileDesc

    if {$layout!={}} { set_board $layout }
    set nTiles 0
    foreach data $tileDesc {
        set y [lindex $data 0]
        set x [lindex $data 1]
        set l [lindex $data 2]
        put $x $y $l [lindex $deck $nTiles]
        incr nTiles
    }
    if {$nTiles!=144} {
        puts stderr "tile description bogus"
        exit 1
    }
}

# this renders the table onto the canvas
proc draw {} {
    global halfw halfh htile tab tfg wtile xhalfw xhalfh
    global classtab tile_info tile_text
    .c delete all
    for {set level 0} {$level<6} {incr level} {
        for {set x 0} {$x<32} {incr x} {
            for {set y 0} {$y<16} {incr y} {
                if ![catch {set img $tab($x:$y:$level)}] {
                    set xx [expr $x*$xhalfw+4+5*$level]
                    set yy [expr $y*$xhalfh+4+5*$level]
                    .c create image $xx $yy -anchor nw -image $img \
                            -tags "$x:$y:$level $img"
                    .c bind $img <1> "doSel $img"
                    .c raise $img
                }
            }
        }
    }
    update
}

# this initializes everything and starts a new game
proc newGame {{layout {}}} {
    setup
    initTab
    shuffle
    deal $layout
    draw
}

# this replays a game
proc replay {} {
    setup
    deal
    draw
}

newGame $startupLayout
foreach b {.about .new .replay .quit .help} {
    $b configure -state normal
}
.c configure -cursor {}

# event bindings
bind .c <3> { if {$sel!={}} {doSel $sel} }

## EOF tkmahjongg.tail
