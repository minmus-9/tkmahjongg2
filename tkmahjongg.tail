########################################################################
## tkmahjongg.tail

# define bitmap data
set bitmap_data(autumn) { }

# default layout
set tileDesc { }

proc set_board name {
    global board_data tileDesc
    set tileDesc [split $board_data($name) "\n"]
}

set_board default

# tile info
# format: tile_class num_to_create list_of_tiles_it_matches
set tile_info(bamboo1) {0 4 {bamboo1}}
set tile_info(bamboo2) {0 4 {bamboo2}}
set tile_info(bamboo3) {0 4 {bamboo3}}
set tile_info(bamboo4) {0 4 {bamboo4}}
set tile_info(bamboo5) {0 4 {bamboo5}}
set tile_info(bamboo6) {0 4 {bamboo6}}
set tile_info(bamboo7) {0 4 {bamboo7}}
set tile_info(bamboo8) {0 4 {bamboo8}}
set tile_info(bamboo9) {0 4 {bamboo9}}
set tile_info(pin1) {1 4 {pin1}}
set tile_info(pin2) {1 4 {pin2}}
set tile_info(pin3) {1 4 {pin3}}
set tile_info(pin4) {1 4 {pin4}}
set tile_info(pin5) {1 4 {pin5}}
set tile_info(pin6) {1 4 {pin6}}
set tile_info(pin7) {1 4 {pin7}}
set tile_info(pin8) {1 4 {pin8}}
set tile_info(pin9) {1 4 {pin9}}
set tile_info(man1) {2 4 {man1}}
set tile_info(man2) {2 4 {man2}}
set tile_info(man3) {2 4 {man3}}
set tile_info(man4) {2 4 {man4}}
set tile_info(man5) {2 4 {man5}}
set tile_info(man6) {2 4 {man6}}
set tile_info(man7) {2 4 {man7}}
set tile_info(man8) {2 4 {man8}}
set tile_info(man9) {2 4 {man9}}
set tile_info(northwind) {3 4 {northwind}}
set tile_info(southwind) {3 4 {southwind}}
set tile_info(eastwind) {3 4 {eastwind}}
set tile_info(westwind) {3 4 {westwind}}
set tile_info(flbamboo) {4 1 {flbamboo florchid flflum flchrys}}
set tile_info(florchid) {4 1 {flbamboo florchid flflum flchrys}}
set tile_info(flflum) {4 1 {flbamboo florchid flflum flchrys}}
set tile_info(flchrys) {4 1 {flbamboo florchid flflum flchrys}}
set tile_info(spring) {5 1 {spring summer autumn winter}}
set tile_info(summer) {5 1 {spring summer autumn winter}}
set tile_info(autumn) {5 1 {spring summer autumn winter}}
set tile_info(winter) {5 1 {spring summer autumn winter}}
set tile_info(dragong) {6 4 {dragong}}
set tile_info(dragonc) {6 4 {dragonc}}
set tile_info(dragonh) {6 4 {dragonh}}

########################################################################

# process args
catch {rename send {}}
if ![catch {set geometry}] {
    catch {wm geometry . $geometry}
}
while {[llength $argv]} {
    if {[lindex $argv 0]=="-i"} {
        wm iconify .
    } elseif {[lindex $argv 0]=="-r"} {
        set swap $wfg
        set wfg $wbg
        set wbg $swap
    } elseif {[lindex $argv 0]=="-vb"} {
        set vbell 1
    } elseif {[lindex $argv 0]=="-l"} {
        set startupFile [lindex $argv 1]
        set argv [lreplace $argv 0 0]
    } elseif {[lindex $argv 0]=="-b"} {
        set rSeed [expr int([lindex $argv 1]) % 1000000000]
        set argv [lreplace $argv 0 0]
    } elseif {[lindex $argv 0]=="-class"} {
        set copt 1
    } else {
        puts stderr "unknown option: [lindex $argv 0]"
        exit 1
    }
    set argv [lreplace $argv 0 0]
}

# create main UI
. configure -background $wbg
# compute grid size if in text mode
set wtile 64
set htile 64

set halfw [expr 0.5*$wtile]
set halfh [expr 0.5*$htile]
set xsp [expr $wtile+4]
set ysp [expr $htile+4]
set xhalfw [expr 0.5*$xsp]
set xhalfh [expr 0.5*$ysp]
canvas .c -width [expr $xsp*15+12] -height [expr $ysp*8+12] \
        -bd 0 -highlightthickness 0 -background $wbg
pack .c -side bottom -padx 2 -pady 2
.c configure -cursor watch

button .about -text $blbl(about) -fg $wfg -bg $wbg \
        -font $blfont -command {
    .c delete all
    .c configure -cursor crosshair
    about
    update
    bind .c <1> {
        .c configure -cursor {}
        bind .c <1> {}
        draw
    }
}
button .new -fg $wfg -bg $wbg -text $blbl(new) \
        -font $blfont -command {
    if [query] newGame
}
button .replay -fg $wfg -bg $wbg -text $blbl(replay) \
        -font $blfont -command {
    if [query] replay
}
button .load -fg $wfg -bg $wbg -text $blbl(load) \
        -font $blfont -command {
    if [query] {
        set f [tk_getOpenFile -parent .c -title {Load Board}]
        if {$f!={}} { newGame $f }
    }
}
button .undo -fg $wfg -bg $wbg -state disabled -font $blfont \
        -text $blbl(undo) \
-command {
    set cmd [lindex $undoInfo end]
    if [catch {set undoInfo [lreplace $undoInfo end end]}] { set undoInfo {} }
    if ![llength $undoInfo] {
        .undo configure -state disabled
    }
    eval $cmd
}
button .quit -fg $wfg -bg $wbg -text Quit -font $blfont \
        -command { if [query] exit }
button .help -fg $wfg -bg $wbg -text Help -font $blfont \
        -command {wm deiconify .xhelp; raise .xhelp}
# labels on right
label .lg -text $blbl(game) -fg $wfg -bg $wbg \
        -font $blfont
label .lgame -textvariable gSeed -width 10 -anchor e -fg $wfg -bg $wbg \
        -font $blfont
# shim
label .ld -width 2 -fg $wfg -bg $wbg
label .lr -text $blbl(rem) -fg $wfg -bg $wbg \
        -font $blfont
label .rem -textvariable nTiles -width 3 -fg $wfg -bg $wbg \
        -font $blfont
foreach b {.about .new .replay .load .quit .help} {
    $b configure -state disabled
}
pack .about .new .replay .load .undo .quit .help -side left
pack .rem .lr .ld .lgame .lg -side right

proc about {} {
    global xhalfh xhalfw wfg

    .c create text [expr $xhalfw*15] [expr $xhalfh*1.0] -text "TkMahjongg" \
        -font -adobe-helvetica-bold-r-*-*-*-240-* -fill $wfg
    .c create text [expr $xhalfw*15] [expr $xhalfh*2.6] \
        -text "by Mark Hays  <hays@azstarnet.com>" \
        -font -adobe-helvetica-bold-r-*-*-*-180-* -fill $wfg
    .c create text [expr $xhalfw*15] [expr $xhalfh*4.5] \
        -font -adobe-helvetica-bold-r-*-*-*-120-* -fill $wfg \
        -anchor center -justify center \
        -text \
{
Copyright (c) 1997 by Mark Hays. All Rights Reserved.

$Id: tkmahjongg,v 1.7 1997/12/08 05:58:51 hays Exp hays $}
    .c create text [expr $xhalfw*15] [expr $xhalfh*7] \
        -font -adobe-helvetica-bold-r-*-*-*-180-* -fill $wfg \
        -anchor n -justify center \
        -text \
{Board layouts and tiles were pilfered from XMahjongg

XMahjongg Layouts are Copyright (c) 1990 by
Jeff Young  <jsy@cray.com>

Graphical Tiles are Copyright (c) 1988 by
Mark Holm  <tektronix!tessi!exc!markh>}
}

about
wm resizable . 0 0
wm title . TkMahjongg
update

# if a game is in progress, confirm a destructive operation
proc query {} {
    if {[.undo cget -state]!={disabled}} {
        return [tk_dialog .qdlg Abort? {Abort Current Game?} {} 0 No Yes]
    }
    return 1
}

# help display
toplevel .xhelp
wm withdraw .xhelp
wm resizable .xhelp 0 0
wm title .xhelp {TkMahjongg Help}
wm protocol .xhelp WM_DELETE_WINDOW {wm withdraw .xhelp}
scrollbar .xhelp.s -orient vertical -command {.xhelp.t yview}
text .xhelp.t -yscrollcommand {.xhelp.s set} -font $hfont -width 66
button .xhelp.b -text Close -command {wm withdraw .xhelp}
pack .xhelp.b -side bottom -fill x
pack .xhelp.s -side right -fill y
pack .xhelp.t -fill both
.xhelp.t insert end $tkmahjongg_help
.xhelp.t configure -state disabled

# create images
set iList {}
foreach name [array names tile_info] {
    foreach {cls n match} $tile_info($name) {
        for {set i 0} {$i<$n} {incr i} {
            set in ${name}_$i
            image create photo $in -data $image_data($name) -format PNG
            $in configure -foreground $tfg \
                    -background [lindex $classtab $cls]
            lappend iList $in
        }
    }
}
unset bitmap_data

# this determines if a tile is free
proc isFree tile {
    global tab

    set tl [.c gettags $tile]
    set xy [split [lindex $tl [lsearch -glob $tl *:*:*]] {:}]
    set x  [lindex $xy 0]
    set y  [lindex $xy 1]
    set l  [lindex $xy 2]
    set no 0
    # check LR
    incr x -2
    if {[array names tab $x:$y:$l]!={}} { incr no } else {
        if {[array names tab $x:[expr $y-1]:$l]!={}} { incr no } else {
            if {[array names tab $x:[expr $y+1]:$l]!={}} { incr no }
        }

    }
    incr x 4
    if {[array names tab $x:$y:$l]!={}} { incr no } else {
        if {[array names tab $x:[expr $y-1]:$l]!={}} { incr no } else {
            if {[array names tab $x:[expr $y+1]:$l]!={}} { incr no }
        }
    }
    incr x -2
    # check above
    incr l
    foreach {dx dy} {-1 -1   0 -1   1 -1
                     -1  0   0  0   1  0
                     -1  1   0  1   1  1} {
        if {[array names tab [expr $x+$dx]:[expr $y+$dy]:$l]!={}} {
            incr no
        }
    }
    # done
    if {$no>1} { return 0 }
    return 1
}

# this gets called when something illegal happens
if !$vbell {
    proc deny {} bell
} else {
    proc deny {} {
        global wfg

        set ob [. cget -background]
        . configure -background $wfg
        update
        after 100
        . configure -background $ob
        update
    }
}

# this reverses a tile's colors
proc revVid tile {
    set bg [$tile cget -foreground]
    set fg [$tile cget -background]
    $tile configure -foreground $fg -background $bg
}

# this proc performs a move
proc doMove {t1 t2} {
    global nTiles sel tab tile_info undoInfo

    # see if they're compatible
    set type1 [lindex [split $t1 {_}] 0]
    set type2 [lindex [split $t2 {_}] 0]
    if {[lsearch -exact [lindex $tile_info($type1) 2] $type2]==-1} {
        deny
        return
    }
    # success!
    # restore selected tile
    revVid $t1
    # delete them
    set u {}
    set tl [.c gettags $t1]
    set xyl [lindex $tl [lsearch -glob $tl *:*:*]]
    unset tab($xyl)
    append u [concat put [split $xyl {:}] $t1]
    .c delete $t1
    .c delete rect_$t1
    set tl [.c gettags $t2]
    set xyl [lindex $tl [lsearch -glob $tl *:*:*]]
    unset tab($xyl)
    append u [concat {;} put [split $xyl {:}] $t2 {;} draw {;} incr nTiles 2]
    .c delete $t2
    .c delete rect_$t2
    incr nTiles -2
    set sel {}
    lappend undoInfo $u
    .undo configure -state normal
}

# this processes mouse events
set sel {}

proc doSel v {
    global sel
    if ![isFree $v] { deny; return }
    if {$v==$sel} {
        # deselect it
        set sel {}
        revVid $v
        set sel {}
    } else {
        # do move
        if {$sel!=""} {
            doMove $sel $v
        # select it
        } else {
            revVid $v
            set sel $v
        }
    }
}

# this flashes all tiles in the selected tile's class
proc doFlash {v {free 1}} {
    global tile_info

    # names of matching tiles
    set matches [lindex $tile_info([lindex [split $v {_}] 0]) 2]
    # build exhaustive list
    set ones {}
    foreach one $matches {
        lappend ones ${one}_0 ${one}_1 ${one}_2 ${one}_3
    }
    # remove ourself
    set ndx [lsearch -exact $ones $v]
    set ones [lreplace $ones $ndx $ndx]
    # build list of free ones
    if $free {
        set todo {}
        foreach one $ones {
            catch {if [isFree $one] {lappend todo $one}}
        }
    } else {
        set todo $ones
    }
    # flash them
    foreach one $todo {catch {revVid $one}}
    update
    after 250
    foreach one $todo {catch {revVid $one}}
    update
}

########################################################################

# this does global game initialization
proc setup {} {
    global undoInfo
    set undoInfo {}
    .undo configure -state disabled
}

# this initializes the tile table
proc initTab {} {
    global tab
    catch {unset tab}
}

if {$rSeed<0} {
    set rSeed [expr [clock seconds] % 1000000000]
    expr srand($rSeed)
}

proc ranbyte {} {
    return [expr int(rand() * 256)]
}

proc pop {x} {
    set p 0
    while {$x > 0} {
        incr p [expr $x  & 1]
        set  x [expr $x >> 1]
    }
    return $p
}

proc cl2 {x} {
    if {$x < 1} { error {x must be positive} }
    set x [expr $x - 1]
    for {set i 0} {$i < 6} {incr i} {
        set x [expr $x | ($x >> (1 << $i))]
    }
    return [pop $x]
}

proc rng {n} {
    if {$n == 1} { return 0 }
    if {$n  < 2} { error {n must be positive} }
    set b [cl2 $n]
    set B [expr ($b + 7) >> 3]
    set N [expr 1 << ($B << 3)]
    set S [expr $N / $n]
    set d [expr $N % $n]
    set L [expr $N - $d]
    while {1} {
        set j 0
        for {set i 0} {$i < $B} {incr i} {
            set j [expr ($j << 8) | [ranbyte]]
        }
        if {$j < $L} { return [expr $j / $S] }
    }
}

proc shuffle {} {
    global deck iList gSeed rSeed
    set gSeed $rSeed
    set rSeed [expr int(rand() * 1000000000)]
    set deck $iList
    for {set i [expr [llength $deck] - 1]} {$i >= 1} {incr i -1} {
        set j [rng $i]
        set t [lindex $deck $i]
        set l [lreplace $deck $i $i [lindex $deck $j]]
        set deck [lreplace $l $j $j $t]
    }
}

# this places a tile into the tile table
proc put {x y l img} {
    global colortab copt tab
    if {!$copt} {$img configure -background [lindex $colortab $l]}
    set tab($x:$y:$l) $img
}

# this reads a tile description file
proc loadFile {{filename {}}} {
    global tileDesc
    if {$filename=={}} return
    set tileDesc {}
    set nLines 0
    set file [open $filename r]
    while {[gets $file line]>=0} {
        set data [lindex [split $line {#}] 0]
        if [llength $data] {
            set y [lindex $data 0]
            set x [lindex $data 1]
            set l [lindex $data 2]
            lappend tileDesc [list $y $x $l]
            incr nLines
        }
    }
    close $file
    if {$nLines!=144} {
        puts stderr "deck description $filename bogus"
        exit 1
    }
}

# this deals the tiles
proc deal {{filename {}}} {
    global deck nTiles tileDesc

    if {$filename!={}} { loadFile $filename }
    set nTiles 0
    foreach data $tileDesc {
        set y [lindex $data 0]
        set x [lindex $data 1]
        set l [lindex $data 2]
        put $x $y $l [lindex $deck $nTiles]
        incr nTiles
    }
    if {$nTiles!=144} {
        puts stderr "tile description bogus"
        exit 1
    }
}

# this renders the table onto the canvas
proc draw {} {
    global copt halfw halfh htile tab tfg tfont wtile xhalfw xhalfh
    global btfont classtab colortab tile_info tile_text
    .c delete all
    for {set level 0} {$level<6} {incr level} {
        set color [lindex $colortab $level]
        for {set x 0} {$x<32} {incr x} {
            for {set y 0} {$y<16} {incr y} {
                if ![catch {set img $tab($x:$y:$level)}] {
                    set xx [expr $x*$xhalfw+6-2*$level]
                    set yy [expr $y*$xhalfh+6-2*$level]
                    .c create image $xx $yy -anchor nw -image $img \
                            -tags "$x:$y:$level $img"
                    .c bind $img <1> "doSel $img"
                    .c raise $img
                }
            }
        }
    }
    update
}

# this initializes everything and starts a new game
proc newGame {{filename {}}} {
    setup
    initTab
    shuffle
    deal $filename
    draw
}

# this replays a game
proc replay {} {
    setup
    deal
    draw
}

newGame $startupFile
foreach b {.about .new .replay .load .quit .help} {
    $b configure -state normal
}
.c configure -cursor {}

# event bindings
bind .c <2> { if {$sel!={}} {doFlash $sel} }
bind .c <Shift-3> { if {$sel!={}} {doFlash $sel} }

bind .c <Control-2> { if {$sel!={}} {doFlash $sel 0} }
bind .c <Control-3> { if {$sel!={}} {doFlash $sel 0} }

bind .c <3> { if {$sel!={}} {doSel $sel} }

## EOF tkmahjongg.tail
